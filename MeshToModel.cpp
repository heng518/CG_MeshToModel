// Include standard headers
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <array>
#include <stack>
#include <sstream>
#include <iostream>
#include <fstream>

// Include GLEW
#include <GL/glew.h>
// Include GLFW
#include <glfw3.h>
// Include GLM
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtx/quaternion.hpp>
using namespace glm;
// Include AntTweakBar
#include <AntTweakBar.h>

#include <common/shader.hpp>
#include <common/controls.hpp>
#include <common/objloader.hpp>
#include <common/vboindexer.hpp>
#include <common/tga.c>
#include <common/ray_casting.h>

using namespace std;

#define PI 3.14159
const int window_width = 600, window_height = 600;

typedef struct Vertex {
    float Position[4];
    float Color[4];
    float Normal[3];
    float UV[2];
    void SetPosition(float *coords) {
        Position[0] = coords[0];
        Position[1] = coords[1];
        Position[2] = coords[2];
        Position[3] = 1.0;
    }
    void SetColor(float *color) {
        Color[0] = color[0];
        Color[1] = color[1];
        Color[2] = color[2];
        Color[3] = color[3];
    }
    void SetNormal(float *coords) {
        Normal[0] = coords[0];
        Normal[1] = coords[1];
        Normal[2] = coords[2];
    }
    void setUV(float * coords) {
        UV[0] = coords[0];
        UV[1] = coords[1];
    }
};

// function prototypes
int initWindow(void);
void initOpenGL(void);
void loadObject(char*, glm::vec4, Vertex * &, GLushort* &, int);
void createVAOs(Vertex[], GLushort[], int);
void createObjects(void);
void pickObject(void);
void renderScene(void);
void cleanup(void);
static void keyCallback(GLFWwindow*, int, int, int, int);
static void mouseCallback(GLFWwindow*, int, int, int);

// GLOBAL VARIABLES
GLFWwindow* window;

glm::mat4 gProjectionMatrix;
glm::mat4 gViewMatrix;

GLuint gPickedIndex = -1;
std::string gMessage;

GLuint programID;
GLuint pickingProgramID;

const GLuint NumObjects = 97;	// ATTN: THIS NEEDS TO CHANGE AS YOU ADD NEW OBJECTS
GLuint VertexArrayId[NumObjects] = { 0 };
GLuint VertexBufferId[NumObjects] = { 0 };
GLuint IndexBufferId[NumObjects] = { 0 };

size_t NumIndices[NumObjects] = { 0 };
size_t VertexBufferSize[NumObjects] = { 0 };
size_t IndexBufferSize[NumObjects] = { 0 };

GLuint MatrixID;
GLuint ModelMatrixID;
GLuint ViewMatrixID;
GLuint ProjMatrixID;
GLuint PickingMatrixID;
GLuint pickingColorID;
GLuint LightID_1;
GLuint LightID_2;
GLuint Texture;
GLuint HairTexture;
GLuint TextureID;

GLint gX = 0.0;
GLint gZ = 0.0;

long TextureHeight;
long TextureWidth;

// camera move
bool moveLeft = false;
bool moveRight = false;
bool moveForward = false;
bool moveBackward = false;
bool resetCamera = false;

// viewmatrix control
glm::vec3 cameraPos;
glm::vec3 cameraUp;

// load model
Vertex* Verts_Model;
GLushort* Idcs_Model;
bool showModel = false;
bool showMesh = false;
Vertex MeshPoints[441];
Vertex MeshHairPoints[441];
Vertex MeshLinePoints[441];
Vertex MeshTexturePoints[441];
Vertex MeshLines[1680];
Vertex MeshTrianglePoints[2400];
Vertex HairTexturePoints[2400];
Vertex MeshSmoothPoints[22600];
float pickingColor[441];
float zpos = 0.0;
GLuint pickingColorArrayID;
bool isPick = false;
bool is_zDirection = false;
glm::vec3 curCoor;
glm::vec3 oriCoor;
bool ray_Casting = false;
bool showTexture = false;
bool smoothSurface = false;
bool showSubdiv = false;
bool smile = false;
bool brown = false;
float smileTime = 0.0f;
float brownTime = 0.0f;
Vertex SmoothMeshPoints[3721];
Vertex SmoothPoints[3721];
//==
void loadObject(char* file, glm::vec2 uv, glm::vec4 color, Vertex * &out_Vertices, GLushort* &out_Indices, int ObjectId)
{
    // Read our .obj file
    std::vector<glm::vec3> vertices;
    std::vector<glm::vec2> uvs;
    std::vector<glm::vec3> normals;
    bool res = loadOBJ(file, vertices, normals);
    
    std::vector<GLushort> indices;
    std::vector<glm::vec3> indexed_vertices;
    std::vector<glm::vec2> indexed_uvs;
    std::vector<glm::vec3> indexed_normals;
    indexVBO(vertices, normals, indices, indexed_vertices, indexed_normals);
    
    const size_t vertCount = indexed_vertices.size();
    const size_t idxCount = indices.size();
    
    // populate output arrays
    out_Vertices = new Vertex[vertCount];
    for (int i = 0; i < vertCount; i++) {
        out_Vertices[i].SetPosition(&indexed_vertices[i].x);
        out_Vertices[i].SetNormal(&indexed_normals[i].x);
        out_Vertices[i].SetColor(&color[0]);
        out_Vertices[i].setUV(&uv[0]);
    }
    out_Indices = new GLushort[idxCount];
    for (int i = 0; i < idxCount; i++) {
        out_Indices[i] = indices[i];
    }
    
    // set global variables!!
    NumIndices[ObjectId] = idxCount;
    VertexBufferSize[ObjectId] = sizeof(out_Vertices[0]) * vertCount;
    IndexBufferSize[ObjectId] = sizeof(GLushort) * idxCount;
}


void createObjects(void)
{
    //-- COORDINATE AXES --//
    Vertex CoordVerts[] =
    {
        { { 0.0, 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 5.0, 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.0, 5.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.0, 0.0, 5.0, 1.0 }, { 0.0, 0.0, 1.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    
    VertexBufferSize[0] = sizeof(CoordVerts);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(CoordVerts, NULL, 0);
    
    //-- GRID --//
    int axisNum = 5;
    Vertex Grid[84];
    int index = 0;
    for (float i = -axisNum; i <= axisNum; i += 0.5) {
        Grid[4 * index] = (Vertex){ { i, 0.0, (float)-axisNum, 1.0 },{ 1.0, 1.0, 1.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} };
        Grid[4 * index + 1] = (Vertex){ { i, 0.0, (float)axisNum, 1.0 }, { 1.0, 1.0, 1.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} };
        Grid[4 * index + 2] = (Vertex){ { (float)-axisNum, 0.0, i, 1.0}, { 1.0, 1.0, 1.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} };
        Grid[4 * index + 3] = (Vertex){ { (float)axisNum, 0.0, i, 1.0 }, { 1.0, 1.0, 1.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} };
        index++;
    }
    
    VertexBufferSize[1] = sizeof(Grid);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Grid, NULL, 1);
    
    //-- .OBJs --//
    
    // ATTN: load your models here
    loadObject("models/yaoheng.obj", glm::vec2(0.0, 0.0), glm::vec4(0.8, 0.65, 0.8, 1.0), Verts_Model, Idcs_Model, 2);
    createVAOs(Verts_Model, Idcs_Model, 2);
    
    
    // CONTROL MESH POINTS
    VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshPoints, NULL, 4);
    
    // CONTROL MESH
    int rowNum = 10;
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            index++;
        }
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
    }
    
    VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshLines, NULL, 3);
    
    // CONTROL MESH TEXTURE TRAINGLE
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            index++;
        }
    }
    VertexBufferSize[5] = sizeof(MeshTrianglePoints);
    createVAOs(MeshTrianglePoints, NULL, 5);
    
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            HairTexturePoints[6 * index + 5] = MeshHairPoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            HairTexturePoints[6 * index + 4] = MeshHairPoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            HairTexturePoints[6 * index + 3] = MeshHairPoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            HairTexturePoints[6 * index + 2] = MeshHairPoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            HairTexturePoints[6 * index + 1] = MeshHairPoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            HairTexturePoints[6 * index] = MeshHairPoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            index++;
        }
    }
    VertexBufferSize[9] = sizeof(HairTexturePoints);
    createVAOs(HairTexturePoints, NULL, 9);
    
    Vertex Curve[] =
    {
        { { -0.91, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.84, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.84, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.79, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.79, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.77, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.77, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.77, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.77, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.78, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.78, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.81, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.81, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.85, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.85, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.89, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.89, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.94, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.94, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.98, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.98, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.01, 6.69, 0.4, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.01, 6.69, 0.4, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.03, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    VertexBufferSize[11] = sizeof(Curve);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Curve, NULL, 11);
    
    Vertex Curve1[] =
    {
        { { -1.31, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.34, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.24, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.19, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.19, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.17, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.17, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.17, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.17, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.18, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.18, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.21, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.21, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.25, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.25, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.29, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.29, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.34, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.34, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.38, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.38, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.41, 6.69, 0.4, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.41, 6.69, 0.4, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.43, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    VertexBufferSize[12] = sizeof(Curve);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Curve1, NULL, 12);
    
    Vertex Curve2[] =
    {
        { { -1.61, 7.32, 2.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.64, 7.33, 2.0, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.54, 7.33, 2.0, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.49, 7.32, 1.87, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.49, 7.32, 1.87, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.47, 7.30, 1.74, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.47, 7.30, 1.74, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.47, 7.26, 1.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.47, 7.26, 1.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.48, 7.2, 1.48, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.48, 7.2, 1.48, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.51, 7.13, 1.34, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.51, 7.13, 1.34, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.55, 7.05, 1.2, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.55, 7.05, 1.2, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.59, 6.97, 1.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.59, 6.97, 1.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.64, 6.88, 0.89, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.64, 6.88, 0.89, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.68, 6.79, 0.71, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.68, 6.79, 0.71, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.71, 6.69, 0.5, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.71, 6.69, 0.5, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.73, 6.6, 0.29, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    VertexBufferSize[13] = sizeof(Curve2);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Curve2, NULL, 13);
    
    Vertex Curve3[] =
    {
        { { -1.11, 7.32, 2.25, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.14, 7.33, 2.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.04, 7.33, 2.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.0, 7.32, 1.97, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.0, 7.32, 1.97, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.93, 7.30, 1.84, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.93, 7.30, 1.84, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.93, 7.26, 1.71, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.93, 7.26, 1.71, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.98, 7.2, 1.58, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -0.98, 7.2, 1.58, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.01, 7.13, 1.44, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.01, 7.13, 1.44, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.05, 7.05, 1.3, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.05, 7.05, 1.3, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.09, 6.97, 1.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.09, 6.97, 1.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.14, 6.88, 0.99, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.14, 6.88, 0.99, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.18, 6.79, 0.81, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.18, 6.79, 0.81, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.21, 6.69, 0.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.21, 6.69, 0.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { -1.23, 6.6, 0.39, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    VertexBufferSize[14] = sizeof(Curve3);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Curve3, NULL, 14);
    
    Vertex Curve4[] =
    {
        { { 0.81, 7.32, 1.25, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.84, 7.33, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.84, 7.33, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.8, 7.32, 0.97, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.8, 7.32, 0.97, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.73, 7.30, 0.84, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.73, 7.30, 0.84, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.73, 7.26, 0.71, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.73, 7.26, 0.71, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.78, 7.2, 0.58, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.78, 7.2, 0.58, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.81, 7.13, 0.44, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.81, 7.13, 0.44, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.81, 7.05, 0.3, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.85, 7.05, 0.3, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.89, 6.97, 0.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.89, 6.97, 0.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.94, 6.88, 0.99, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.94, 6.88, 0.99, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.94, 6.79, 0.81, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.94, 6.79, 0.81, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 1.01, 6.69, 0.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 1.01, 6.69, 0.15, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 1.03, 6.6, 0.39, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    VertexBufferSize[15] = sizeof(Curve4);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Curve4, NULL, 15);
    
    Vertex Curve5[] =
    {
        { { 0.41, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.44, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.44, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.4, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.4, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.33, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.33, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.33, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.33, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.38, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.38, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.51, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.51, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.51, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.55, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.59, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.59, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.54, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.54, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.54, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.54, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.61, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.61, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        { { 0.63, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
    };
    VertexBufferSize[16] = sizeof(Curve5);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(Curve5, NULL, 16);
    
    for (int i = 0; i < 20 ; i++) {
        Vertex Curve6[] =
        {
            { { 0.01 + 0.05*i, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.04  + 0.05*i, 7.33, 1.9 , 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.04 + 0.05*i, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.0 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.0 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.07 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.07 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.07 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.07 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.02 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.02 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.11 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.11 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.11 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.15 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.19 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.19 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.14 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.14 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.14 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.14 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.21 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.21 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { 0.23 + 0.05*i, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        };
        VertexBufferSize[17+i] = sizeof(Curve6);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(Curve6, NULL, 17+i);
    }
    for (int i = 0; i < 20 ; i++) {
        Vertex Curve6[] =
        {
            { { -0.49 + 0.05*i, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.46  + 0.05*i, 7.33, 1.9 , 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.46 + 0.05*i, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.5 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.5 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.57 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.57 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.57 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.57 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.52 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.52 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.39 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.39 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.39 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.35 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.31 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.31 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.36 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.36 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.36 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.36 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.29 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.29 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.27 + 0.05*i, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        };
        VertexBufferSize[37+i] = sizeof(Curve6);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(Curve6, NULL, 37+i);
    }
    for (int i = 0; i < 20 ; i++) {
        Vertex Curve6[] =
        {
            { { -0.99 + 0.05*i, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.96  + 0.05*i, 7.33, 1.9 , 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.96 + 0.05*i, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.0 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.0 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.07 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.07 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.07 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.07 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.02 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.02 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.89 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.89 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.89 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.85 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.81 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.81 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.86 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.86 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.86 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.86 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.79 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.79 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -0.77 + 0.05*i, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        };
        VertexBufferSize[57+i] = sizeof(Curve6);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(Curve6, NULL, 57+i);
    }
    
    for (int i = 0; i < 20 ; i++) {
        Vertex Curve6[] =
        {
            { { -1.49 + 0.05*i, 7.32, 2.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.46  + 0.05*i, 7.33, 1.9 , 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.46 + 0.05*i, 7.33, 1.9, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.5 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.5 + 0.05*i, 7.32, 1.77, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.57 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.57 + 0.05*i, 7.30, 1.64, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.57 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.57 + 0.05*i, 7.26, 1.51, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.52 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.52 + 0.05*i, 7.2, 1.38, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.39 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.39 + 0.05*i, 7.13, 1.24, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.39 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.35 + 0.05*i, 7.05, 1.1, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.31 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.31 + 0.05*i, 6.97, 0.95, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.36 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.36 + 0.05*i, 6.88, 0.79, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.36 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.36 + 0.05*i, 6.79, 0.61, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.29 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.29 + 0.05*i, 6.69, -0.05, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
            { { -1.27 + 0.05*i, 6.6, 0.19, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {0.0, 0.0} },
        };
        VertexBufferSize[77+i] = sizeof(Curve6);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(Curve6, NULL, 57+i);
    }
}

void renderSmooth()
{
    float color[3] = { 0.0f, 0.0f, 0.0f };
    for (int i = 1; i < 20; i++)
    {
        for (int j = 1; j < 20; j++)
        {
            Vertex s11 = MeshPoints[i * 21 + j];
            Vertex s12 = MeshPoints[(i + 1) * 21 + j];
            Vertex s21 = MeshPoints[i * 21 + j + 1];
            Vertex s10 = MeshPoints[(i - 1) * 21 + j];
            Vertex s01 = MeshPoints[i * 21 + j - 1];
            Vertex s00 = MeshPoints[(i - 1) * 21 + j - 1];
            Vertex s20 = MeshPoints[(i - 1) * 21 + j + 1];
            Vertex s02 = MeshPoints[(i + 1) * 21 + j - 1];
            Vertex s22 = MeshPoints[(i + 1) * 21 + j + 1];
            SmoothMeshPoints[183 * i + 3 * j].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 1].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 2].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 61].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 62].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 63].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 122].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 123].SetColor(color);
            SmoothMeshPoints[183 * i + 3 * j + 124].SetColor(color);
            
            SmoothMeshPoints[183 * i + 3 * j].Position[0] = (16 * s11.Position[0] + 4 * (s21.Position[0] + s12.Position[0] + s01.Position[0] + s10.Position[0]) + s22.Position[0] + s02.Position[0] + s00.Position[0] + s20.Position[0]) / 36;
            SmoothMeshPoints[183 * i + 3 * j].Position[1] = (16 * s11.Position[1] + 4 * (s21.Position[1] + s12.Position[1] + s01.Position[1] + s10.Position[1]) + s22.Position[1] + s02.Position[1] + s00.Position[1] + s20.Position[1]) / 36;
            SmoothMeshPoints[183 * i + 3 * j].Position[2] = (16 * s11.Position[2] + 4 * (s21.Position[2] + s12.Position[2] + s01.Position[2] + s10.Position[2]) + s22.Position[2] + s02.Position[2] + s00.Position[2] + s20.Position[2]) / 36;
            
            SmoothMeshPoints[183 * i + 3 * j + 1].Position[0] = (8 * s11.Position[0] + 2 * (s10.Position[0] + s12.Position[0]) + 4 * s21.Position[0] + s22.Position[0] + s20.Position[0]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 1].Position[1] = (8 * s11.Position[1] + 2 * (s10.Position[1] + s12.Position[1]) + 4 * s21.Position[1] + s22.Position[1] + s20.Position[1]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 1].Position[2] = (8 * s11.Position[2] + 2 * (s10.Position[2] + s12.Position[2]) + 4 * s21.Position[2] + s22.Position[2] + s20.Position[2]) / 18;
            
            SmoothMeshPoints[183 * i + 3 * j + 2].Position[0] = (8 * s21.Position[0] + 2 * (s22.Position[0] + s20.Position[0]) + 4 * s11.Position[0] + s12.Position[0] + s10.Position[0]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 2].Position[1] = (8 * s21.Position[1] + 2 * (s22.Position[1] + s20.Position[1]) + 4 * s11.Position[1] + s12.Position[1] + s10.Position[1]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 2].Position[2] = (8 * s21.Position[2] + 2 * (s22.Position[2] + s20.Position[2]) + 4 * s11.Position[2] + s12.Position[2] + s10.Position[2]) / 18;
            
            SmoothMeshPoints[183 * i + 3 * j + 61].Position[0] = (8 * s11.Position[0] + 2 * (s01.Position[0] + s21.Position[0]) + 4 * s12.Position[0] + s02.Position[0] + s22.Position[0]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 61].Position[1] = (8 * s11.Position[1] + 2 * (s01.Position[1] + s21.Position[1]) + 4 * s12.Position[1] + s02.Position[1] + s22.Position[1]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 61].Position[2] = (8 * s11.Position[2] + 2 * (s01.Position[2] + s21.Position[2]) + 4 * s12.Position[2] + s02.Position[2] + s22.Position[2]) / 18;
            
            SmoothMeshPoints[183 * i + 3 * j + 62].Position[0] = (4 * s11.Position[0] + 2 * (s21.Position[0] + s12.Position[0]) + s22.Position[0]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 62].Position[1] = (4 * s11.Position[1] + 2 * (s21.Position[1] + s12.Position[1]) + s22.Position[1]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 62].Position[2] = (4 * s11.Position[2] + 2 * (s21.Position[2] + s12.Position[2]) + s22.Position[2]) / 9;
            
            SmoothMeshPoints[183 * i + 3 * j + 63].Position[0] = (4 * s21.Position[0] + 2 * (s11.Position[0] + s22.Position[0]) + s12.Position[0]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 63].Position[1] = (4 * s21.Position[1] + 2 * (s11.Position[1] + s22.Position[1]) + s12.Position[1]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 63].Position[2] = (4 * s21.Position[2] + 2 * (s11.Position[2] + s22.Position[2]) + s12.Position[2]) / 9;
            
            SmoothMeshPoints[183 * i + 3 * j + 122].Position[0] = (8 * s12.Position[0] + 2 * (s02.Position[0] + s22.Position[0]) + 4 * s11.Position[0] + s01.Position[0] + s21.Position[0]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 122].Position[1] = (8 * s12.Position[1] + 2 * (s02.Position[1] + s22.Position[1]) + 4 * s11.Position[1] + s01.Position[1] + s21.Position[1]) / 18;
            SmoothMeshPoints[183 * i + 3 * j + 122].Position[2] = (8 * s12.Position[2] + 2 * (s02.Position[2] + s22.Position[2]) + 4 * s11.Position[2] + s01.Position[2] + s21.Position[2]) / 18;
            
            SmoothMeshPoints[183 * i + 3 * j + 123].Position[0] = (4 * s12.Position[0] + 2 * (s11.Position[0] + s22.Position[0]) + s21.Position[0]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 123].Position[1] = (4 * s12.Position[1] + 2 * (s11.Position[1] + s22.Position[1]) + s21.Position[1]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 123].Position[2] = (4 * s12.Position[2] + 2 * (s11.Position[2] + s22.Position[2]) + s21.Position[2]) / 9;
            
            SmoothMeshPoints[183 * i + 3 * j + 124].Position[0] = (4 * s22.Position[0] + 2 * (s12.Position[0] + s21.Position[0]) + s11.Position[0]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 124].Position[1] = (4 * s22.Position[1] + 2 * (s12.Position[1] + s21.Position[1]) + s11.Position[1]) / 9;
            SmoothMeshPoints[183 * i + 3 * j + 124].Position[2] = (4 * s22.Position[2] + 2 * (s12.Position[2] + s21.Position[2]) + s11.Position[2]) / 9;
        }
    }
    for (int i = 0; i < 20; i++)
    {
        Vertex s11 = MeshPoints[i];
        Vertex s21 = MeshPoints[i + 1];
        Vertex s12 = MeshPoints[i + 21];
        Vertex s22 = MeshPoints[i + 22];
        SmoothMeshPoints[3 * i].SetColor(color);
        SmoothMeshPoints[3 * i + 1].SetColor(color);
        SmoothMeshPoints[3 * i + 2].SetColor(color);
        SmoothMeshPoints[3 * i + 61].SetColor(color);
        SmoothMeshPoints[3 * i + 62].SetColor(color);
        SmoothMeshPoints[3 * i + 63].SetColor(color);
        SmoothMeshPoints[3 * i + 122].SetColor(color);
        SmoothMeshPoints[3 * i + 123].SetColor(color);
        SmoothMeshPoints[3 * i + 124].SetColor(color);
        
        SmoothMeshPoints[3 * i].Position[0] = MeshPoints[i].Position[0];
        SmoothMeshPoints[3 * i].Position[1] = MeshPoints[i].Position[1];
        SmoothMeshPoints[3 * i].Position[2] = MeshPoints[i].Position[2];
        SmoothMeshPoints[3 * i + 1].Position[0] = (2 * MeshPoints[i].Position[0] + MeshPoints[i + 1].Position[0]) / 3;
        SmoothMeshPoints[3 * i + 1].Position[1] = (2 * MeshPoints[i].Position[1] + MeshPoints[i + 1].Position[1]) / 3;
        SmoothMeshPoints[3 * i + 1].Position[2] = (2 * MeshPoints[i].Position[2] + MeshPoints[i + 1].Position[2]) / 3;
        SmoothMeshPoints[3 * i + 2].Position[0] = (MeshPoints[i].Position[0] + 2 * MeshPoints[i + 1].Position[0]) / 3;
        SmoothMeshPoints[3 * i + 2].Position[1] = (MeshPoints[i].Position[1] + 2 * MeshPoints[i + 1].Position[1]) / 3;
        SmoothMeshPoints[3 * i + 2].Position[2] = (MeshPoints[i].Position[2] + 2 * MeshPoints[i + 1].Position[2]) / 3;
        
        SmoothMeshPoints[3 * i + 61].Position[0] = (2 * s11.Position[0] + s12.Position[0]) / 3;
        SmoothMeshPoints[3 * i + 61].Position[1] = (2 * s11.Position[1] + s12.Position[1]) / 3;
        SmoothMeshPoints[3 * i + 61].Position[2] = (2 * s11.Position[2] + s12.Position[2]) / 3;
        SmoothMeshPoints[3 * i + 62].Position[0] = (4 * s11.Position[0] + 2 * (s12.Position[0] + s21.Position[0]) + s22.Position[0]) / 9;
        SmoothMeshPoints[3 * i + 62].Position[1] = (4 * s11.Position[1] + 2 * (s12.Position[1] + s21.Position[1]) + s22.Position[1]) / 9;
        SmoothMeshPoints[3 * i + 62].Position[2] = (4 * s11.Position[2] + 2 * (s12.Position[2] + s21.Position[2]) + s22.Position[2]) / 9;
        SmoothMeshPoints[3 * i + 63].Position[0] = (4 * s21.Position[0] + 2 * (s11.Position[0] + s22.Position[0]) + s12.Position[0]) / 9;
        SmoothMeshPoints[3 * i + 63].Position[1] = (4 * s21.Position[1] + 2 * (s11.Position[1] + s22.Position[1]) + s12.Position[1]) / 9;
        SmoothMeshPoints[3 * i + 63].Position[2] = (4 * s21.Position[2] + 2 * (s11.Position[2] + s22.Position[2]) + s12.Position[2]) / 9;
        
        SmoothMeshPoints[3 * i + 122].Position[0] = (s11.Position[0] + 2 * s12.Position[0]) / 3;
        SmoothMeshPoints[3 * i + 122].Position[1] = (s11.Position[1] + 2 * s12.Position[1]) / 3;
        SmoothMeshPoints[3 * i + 122].Position[2] = (s11.Position[2] + 2 * s12.Position[2]) / 3;
        SmoothMeshPoints[3 * i + 123].Position[0] = (4 * s12.Position[0] + 2 * (s11.Position[0] + s22.Position[0]) + s21.Position[0]) / 9;
        SmoothMeshPoints[3 * i + 123].Position[1] = (4 * s12.Position[1] + 2 * (s11.Position[1] + s22.Position[1]) + s21.Position[1]) / 9;
        SmoothMeshPoints[3 * i + 123].Position[2] = (4 * s12.Position[2] + 2 * (s11.Position[2] + s22.Position[2]) + s21.Position[2]) / 9;
        SmoothMeshPoints[3 * i + 124].Position[0] = (4 * s22.Position[0] + 2 * (s12.Position[0] + s21.Position[0]) + s11.Position[0]) / 9;
        SmoothMeshPoints[3 * i + 124].Position[1] = (4 * s22.Position[1] + 2 * (s12.Position[1] + s21.Position[1]) + s11.Position[1]) / 9;
        SmoothMeshPoints[3 * i + 124].Position[2] = (4 * s22.Position[2] + 2 * (s12.Position[2] + s21.Position[2]) + s11.Position[2]) / 9;
    }
    for (int i = 0; i < 19; i++)
    {
        Vertex s11 = MeshPoints[21 * (i + 1)];
        Vertex s12 = MeshPoints[21 * (i + 2)];
        Vertex s21 = MeshPoints[21 * (i + 1) + 1];
        Vertex s22 = MeshPoints[21 * (i + 2) + 1];
        SmoothMeshPoints[183 + 183 * i].SetColor(color);
        SmoothMeshPoints[183 + 183 * i + 1].SetColor(color);
        SmoothMeshPoints[183 + 183 * i + 2].SetColor(color);
        SmoothMeshPoints[244 + 183 * i].SetColor(color);
        SmoothMeshPoints[244 + 183 * i + 1].SetColor(color);
        SmoothMeshPoints[244 + 183 * i + 2].SetColor(color);
        SmoothMeshPoints[305 + 183 * i].SetColor(color);
        SmoothMeshPoints[305 + 183 * i + 1].SetColor(color);
        SmoothMeshPoints[305 + 183 * i + 2].SetColor(color);
        
        SmoothMeshPoints[183 + 183 * i].Position[0] = s11.Position[0];
        SmoothMeshPoints[183 + 183 * i].Position[1] = s11.Position[1];
        SmoothMeshPoints[183 + 183 * i].Position[2] = s11.Position[2];
        SmoothMeshPoints[183 + 183 * i + 1].Position[0] = (2 * s11.Position[0] + s21.Position[0]) / 3;
        SmoothMeshPoints[183 + 183 * i + 1].Position[1] = (2 * s11.Position[1] + s21.Position[1]) / 3;
        SmoothMeshPoints[183 + 183 * i + 1].Position[2] = (2 * s11.Position[2] + s21.Position[2]) / 3;
        SmoothMeshPoints[183 + 183 * i + 2].Position[0] = (s11.Position[0] + 2 * s21.Position[0]) / 3;
        SmoothMeshPoints[183 + 183 * i + 2].Position[1] = (s11.Position[1] + 2 * s21.Position[1]) / 3;
        SmoothMeshPoints[183 + 183 * i + 2].Position[2] = (s11.Position[2] + 2 * s21.Position[2]) / 3;
        
        SmoothMeshPoints[244 + 183 * i].Position[0] = (2 * s11.Position[0] + s12.Position[0]) / 3;
        SmoothMeshPoints[244 + 183 * i].Position[1] = (2 * s11.Position[1] + s12.Position[1]) / 3;
        SmoothMeshPoints[244 + 183 * i].Position[2] = (2 * s11.Position[2] + s12.Position[2]) / 3;
        SmoothMeshPoints[244 + 183 * i + 1].Position[0] = (4 * s11.Position[0] + 2 * (s12.Position[0] + s21.Position[0]) + s22.Position[0]) / 9;
        SmoothMeshPoints[244 + 183 * i + 1].Position[1] = (4 * s11.Position[1] + 2 * (s12.Position[1] + s21.Position[1]) + s22.Position[1]) / 9;
        SmoothMeshPoints[244 + 183 * i + 1].Position[2] = (4 * s11.Position[2] + 2 * (s12.Position[2] + s21.Position[2]) + s22.Position[2]) / 9;
        SmoothMeshPoints[244 + 183 * i + 2].Position[0] = (4 * s21.Position[0] + 2 * (s11.Position[0] + s22.Position[0]) + s12.Position[0]) / 9;
        SmoothMeshPoints[244 + 183 * i + 2].Position[1] = (4 * s21.Position[1] + 2 * (s11.Position[1] + s22.Position[1]) + s12.Position[1]) / 9;
        SmoothMeshPoints[244 + 183 * i + 2].Position[2] = (4 * s21.Position[2] + 2 * (s11.Position[2] + s22.Position[2]) + s12.Position[2]) / 9;
        
        SmoothMeshPoints[305 + 183 * i].Position[0] = (2 * s12.Position[0] + s11.Position[0]) / 3;
        SmoothMeshPoints[305 + 183 * i].Position[1] = (2 * s12.Position[1] + s11.Position[1]) / 3;
        SmoothMeshPoints[305 + 183 * i].Position[2] = (2 * s12.Position[2] + s11.Position[2]) / 3;
        SmoothMeshPoints[305 + 183 * i + 1].Position[0] = (4 * s12.Position[0] + 2 * (s11.Position[0] + s22.Position[0]) + s21.Position[0]) / 9;
        SmoothMeshPoints[305 + 183 * i + 1].Position[1] = (4 * s12.Position[1] + 2 * (s11.Position[1] + s22.Position[1]) + s21.Position[1]) / 9;
        SmoothMeshPoints[305 + 183 * i + 1].Position[2] = (4 * s12.Position[2] + 2 * (s11.Position[2] + s22.Position[2]) + s21.Position[2]) / 9;
        SmoothMeshPoints[305 + 183 * i + 2].Position[0] = (4 * s22.Position[0] + 2 * (s12.Position[0] + s21.Position[0]) + s11.Position[0]) / 9;
        SmoothMeshPoints[305 + 183 * i + 2].Position[1] = (4 * s22.Position[1] + 2 * (s12.Position[1] + s21.Position[1]) + s11.Position[1]) / 9;
        SmoothMeshPoints[305 + 183 * i + 2].Position[2] = (4 * s22.Position[2] + 2 * (s12.Position[2] + s21.Position[2]) + s11.Position[2]) / 9;
    }
    for (int i = 0; i < 20; i++)
    {
        SmoothMeshPoints[3660 + 3 * i].SetColor(color);
        SmoothMeshPoints[3660 + 3 * i + 1].SetColor(color);
        SmoothMeshPoints[3660 + 3 * i + 2].SetColor(color);
        
        SmoothMeshPoints[3660 + 3 * i].Position[0] = MeshPoints[420 + i].Position[0];
        SmoothMeshPoints[3660 + 3 * i].Position[1] = MeshPoints[420 + i].Position[1];
        SmoothMeshPoints[3660 + 3 * i].Position[2] = MeshPoints[420 + i].Position[2];
        SmoothMeshPoints[3660 + 3 * i + 1].Position[0] = (2 * MeshPoints[420 + i].Position[0] + MeshPoints[420 + i + 1].Position[0]) / 3;
        SmoothMeshPoints[3660 + 3 * i + 1].Position[1] = (2 * MeshPoints[420 + i].Position[1] + MeshPoints[420 + i + 1].Position[1]) / 3;
        SmoothMeshPoints[3660 + 3 * i + 1].Position[2] = (2 * MeshPoints[420 + i].Position[2] + MeshPoints[420 + i + 1].Position[2]) / 3;
        SmoothMeshPoints[3660 + 3 * i + 2].Position[0] = (MeshPoints[420 + i].Position[0] + 2 * MeshPoints[420 + i + 1].Position[0]) / 3;
        SmoothMeshPoints[3660 + 3 * i + 2].Position[1] = (MeshPoints[420 + i].Position[1] + 2 * MeshPoints[420 + i + 1].Position[1]) / 3;
        SmoothMeshPoints[3660 + 3 * i + 2].Position[2] = (MeshPoints[420 + i].Position[2] + 2 * MeshPoints[420 + i + 1].Position[2]) / 3;
    }

    for (int i = 0; i < 60; i += 3)
    {
        int begin = floor(i / 3);
        SmoothMeshPoints[60 + 61 * i].SetColor(color);
        SmoothMeshPoints[60 + 61 * (i + 1)].SetColor(color);
        SmoothMeshPoints[60 + 61 * (i + 2)].SetColor(color);
        
        SmoothMeshPoints[60 + 61 * i].Position[0] = MeshPoints[20 + 21 * begin].Position[0];
        SmoothMeshPoints[60 + 61 * i].Position[1] = MeshPoints[20 + 21 * begin].Position[1];
        SmoothMeshPoints[60 + 61 * i].Position[2] = MeshPoints[20 + 21 * begin].Position[2];
        
        SmoothMeshPoints[60 + 61 * (i + 1)].Position[0] = (2 * MeshPoints[20 + 21 * begin].Position[0] + MeshPoints[20 + 21 * (begin + 1)].Position[0]) / 3;
        SmoothMeshPoints[60 + 61 * (i + 1)].Position[1] = (2 * MeshPoints[20 + 21 * begin].Position[1] + MeshPoints[20 + 21 * (begin + 1)].Position[1]) / 3;
        SmoothMeshPoints[60 + 61 * (i + 1)].Position[2] = (2 * MeshPoints[20 + 21 * begin].Position[2] + MeshPoints[20 + 21 * (begin + 1)].Position[2]) / 3;
        
        SmoothMeshPoints[60 + 61 * (i + 2)].Position[0] = (MeshPoints[20 + 21 * begin].Position[0] + 2 * MeshPoints[20 + 21 * (begin + 1)].Position[0]) / 3;
        SmoothMeshPoints[60 + 61 * (i + 2)].Position[1] = (MeshPoints[20 + 21 * begin].Position[1] + 2 * MeshPoints[20 + 21 * (begin + 1)].Position[1]) / 3;
        SmoothMeshPoints[60 + 61 * (i + 2)].Position[2] = (MeshPoints[20 + 21 * begin].Position[2] + 2 * MeshPoints[20 + 21 * (begin + 1)].Position[2]) / 3;
    }
    SmoothMeshPoints[3720].Position[0] = MeshPoints[440].Position[0];
    SmoothMeshPoints[3720].Position[1] = MeshPoints[440].Position[1];
    SmoothMeshPoints[3720].Position[2] = MeshPoints[440].Position[2];
    VertexBufferSize[6] = sizeof(SmoothMeshPoints);
    createVAOs(SmoothMeshPoints, NULL, 6);
    
    for (int i = 0; i < 60; i++)
    {
        for (int j = 0; j < 60; j++)
        {
            float uv[2] = {0, 0};
            uv[0] = float(j) / 60.0;
            uv[1] = float(i) / 60.0;
            SmoothMeshPoints[i * 61 + j].setUV(uv);
        }
    }
    int index = 0;
    for (int i = 0; i < 60; i++)
    {
        for (int j = 0; j < 60; j++)
        {
            MeshSmoothPoints[6 * index] = SmoothMeshPoints[i * 61 + j];
            MeshSmoothPoints[6 * index + 1] = SmoothMeshPoints[i * 61 + j + 1];
            MeshSmoothPoints[6 * index + 2] = SmoothMeshPoints[(i + 1) * 61 + (j + 1)];
            MeshSmoothPoints[6 * index + 3] = SmoothMeshPoints[(i + 1) * 61 + (j + 1)];
            MeshSmoothPoints[6 * index + 4] = SmoothMeshPoints[(i + 1) * 61 + j];
            MeshSmoothPoints[6 * index + 5] = SmoothMeshPoints[i * 61 + j];
            index++;
        }
    }
    
    for (int i = 0; i < 3721; i++)
    {
        float smooth_color[3] = {1.0, 0.0, 0.0};
        SmoothPoints[i] = SmoothMeshPoints[i];
        SmoothPoints[i].SetColor(smooth_color);
    }
    VertexBufferSize[7] = sizeof(MeshSmoothPoints);
    createVAOs(MeshSmoothPoints, NULL, 7);
    VertexBufferSize[8] = sizeof(SmoothPoints);
    createVAOs(SmoothPoints, NULL, 8);
}

void rayCasting(void)
{
    Vertex* Vertices;
    GLushort* Indices;
    float barycentric_Coor[3];
    float ray_Direction[3] = { 0.0, 0.0, 1.0 };
    bool isMapped = false;
    float resultPos[4];

    loadObject("models/yaoheng.obj", glm::vec2(0.0, 0.0), glm::vec4(0.8, 0.65, 0.8, 1.0), Vertices, Indices, 2);
    for (int meshPoints_Index = 0; meshPoints_Index < 441; meshPoints_Index++)
    {
        for (int triangle_Index = 0; triangle_Index < NumIndices[2] / 3; triangle_Index++)
        {
            Vertex first = Vertices[Indices[triangle_Index * 3]];
            Vertex second = Vertices[Indices[triangle_Index * 3 + 1]];
            Vertex third = Vertices[Indices[triangle_Index * 3 + 2]];
            ray_cast(first.Position, second.Position, third.Position, MeshPoints[meshPoints_Index].Position, ray_Direction, barycentric_Coor);
            
            if (barycentric_Coor[0] >= 0 && barycentric_Coor[1] >= 0 && barycentric_Coor[2] >= 0)
            {
                float tempZ = barycentric_Coor[0] * first.Position[2] + barycentric_Coor[1] * second.Position[2] + barycentric_Coor[2] * third.Position[2];
                if (tempZ > MeshPoints[meshPoints_Index].Position[2])
                {
                    isMapped = true;
                    for (int i = 0; i<2; i++) {
                        resultPos[i] = barycentric_Coor[0] * first.Position[i] + barycentric_Coor[1] * second.Position[i] + barycentric_Coor[2] * third.Position[i];
                    }
                    resultPos[2] = tempZ + 1.3;
                    resultPos[3] = 1.0;
                    MeshPoints[meshPoints_Index].SetPosition(resultPos);
                    MeshLinePoints[meshPoints_Index].SetPosition(resultPos);
                    MeshTexturePoints[meshPoints_Index].SetPosition(resultPos);
                    
                }
            }
        }
        if (!isMapped)
        {
            MeshPoints[meshPoints_Index].Position[2] = 0.0;
            MeshLinePoints[meshPoints_Index].Position[2] = 0.0;
            MeshTexturePoints[meshPoints_Index].Position[2] = 0.0;
        }
        else
            isMapped = false;
    }

    glDeleteBuffers(1, &VertexBufferId[3]);
    glDeleteBuffers(1, &IndexBufferId[3]);
    glDeleteVertexArrays(1, &VertexArrayId[3]);
    
    glDeleteBuffers(1, &VertexBufferId[4]);
    glDeleteBuffers(1, &IndexBufferId[4]);
    glDeleteVertexArrays(1, &VertexArrayId[4]);
    
    glDeleteBuffers(1, &VertexBufferId[5]);
    glDeleteBuffers(1, &IndexBufferId[5]);
    glDeleteVertexArrays(1, &VertexArrayId[5]);
    
    VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshPoints, NULL, 4);
    
    // CONTROL MESH
    int rowNum = 10;
    int index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            index++;
        }
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
    }
    
    VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshLines, NULL, 3);
    
    // CONTROL MESH TEXTURE TRAINGLE
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            index++;
        }
    }
    VertexBufferSize[5] = sizeof(MeshTrianglePoints);
    createVAOs(MeshTrianglePoints, NULL, 5);
    


}

void renderScene(void)
{
    //ATTN: DRAW YOUR SCENE HERE. MODIFY/ADAPT WHERE NECESSARY!
    
    
    // Dark blue background
    glClearColor(0.0f, 0.0f, 0.2f, 0.0f);
    // Re-clear the screen for real rendering
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    mat4 rotationLRMatrix = mat4(1.0);
    mat4 rotationUDMatrix = mat4(1.0);
    
    if (moveLeft)
        rotationLRMatrix = mat4(cos(PI / 180), 0, sin(PI / 180), 0,
                                0, 1, 0, 0,
                                -sin(PI / 180), 0, cos(PI / 180), 0,
                                0, 0, 0, 1);
    else if (moveRight)
        rotationLRMatrix = mat4(cos(PI / 180), 0, -sin(PI / 180), 0,
                                0, 1, 0, 0,
                                sin(PI / 180), 0, cos(PI / 180), 0,
                                0, 0, 0, 1);
    if (moveForward)
    {
        float rotate_X = 0;
        float rotate_Z = 0;
        if (cameraPos.x != 0 && cameraPos.z != 0)
        {
            if (cameraPos.x * cameraPos.z > 0) {
                rotate_X = abs(cameraPos.z / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
                rotate_Z = -abs(cameraPos.x / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
            }
            else
            {
                rotate_X = abs(cameraPos.z / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
                rotate_Z = abs(cameraPos.x / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
            }
        }
        rotationUDMatrix = mat4(pow(rotate_X, 2) + (1 - pow(rotate_X, 2)) * cos(PI/180), -rotate_Z * sin(PI/180), rotate_X * rotate_Z * (1 - cos(PI/180)), 0,
                                rotate_Z * sin(PI/180), cos(PI/180), -rotate_X * sin(PI/180), 0,
                                rotate_X * rotate_Z * (1 - cos(PI/180)), rotate_X * sin(PI/180), pow(rotate_Z, 2) + (1 - pow(rotate_Z, 2)) * cos(PI/180), 0,
                                0, 0, 0, 1);
    }
    else if (moveBackward)
    {
        float rotate_X = 0;
        float rotate_Z = 0;
        if (cameraPos.x != 0 && cameraPos.z != 0)
        {
            if (cameraPos.x * cameraPos.z > 0) {
                rotate_X = abs(cameraPos.z / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
                rotate_Z = -abs(cameraPos.x / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
            }
            else
            {
                rotate_X = abs(cameraPos.z / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
                rotate_Z = abs(cameraPos.x / sqrt(cameraPos.x * cameraPos.x + cameraPos.z * cameraPos.z));
            }
        }
        rotationUDMatrix = mat4(pow(rotate_X, 2) + (1 - pow(rotate_X, 2)) * cos(PI/180), rotate_Z * sin(PI/180), rotate_X * rotate_Z * (1 - cos(PI/180)), 0,
                                -rotate_Z * sin(PI/180), cos(PI/180), rotate_X * sin(PI/180), 0,
                                rotate_X * rotate_Z * (1 - cos(PI/180)), -rotate_X * sin(PI/180), pow(rotate_Z, 2) + (1 - pow(rotate_Z, 2)) * cos(PI/180), 0,
                                0, 0, 0, 1);
    }
    if (smile)
    {
        if (smileTime > 1.5)
            smile = false;
        MeshPoints[92].Position[1] += 0.002f;
        MeshLinePoints[92].Position[1] += 0.002f;
        MeshTexturePoints[92].Position[1] += 0.002f;
        
        MeshPoints[92].Position[0] -= 0.002f;
        MeshLinePoints[92].Position[0] -= 0.002f;
        MeshTexturePoints[92].Position[0] -= 0.002f;
        
        MeshPoints[94].Position[1] += 0.002f;
        MeshLinePoints[94].Position[1] += 0.002f;
        MeshTexturePoints[94].Position[1] += 0.002f;
        
        MeshPoints[113].Position[1] += 0.002f;
        MeshLinePoints[113].Position[1] += 0.002f;
        MeshTexturePoints[113].Position[1] += 0.002f;
        MeshPoints[113].Position[0] -= 0.002f;
        MeshLinePoints[113].Position[0] -= 0.002f;
        MeshTexturePoints[113].Position[0] -= 0.002f;
        
        MeshPoints[115].Position[1] += 0.001f;
        MeshLinePoints[115].Position[1] += 0.001f;
        MeshTexturePoints[115].Position[1] += 0.001f;
        MeshPoints[115].Position[0] += 0.001f;
        MeshLinePoints[115].Position[0] += 0.001f;
        MeshTexturePoints[115].Position[0] += 0.001f;
        
        
        glDeleteBuffers(1, &VertexBufferId[3]);
        glDeleteBuffers(1, &IndexBufferId[3]);
        glDeleteVertexArrays(1, &VertexArrayId[3]);
        
        glDeleteBuffers(1, &VertexBufferId[4]);
        glDeleteBuffers(1, &IndexBufferId[4]);
        glDeleteVertexArrays(1, &VertexArrayId[4]);
        
        glDeleteBuffers(1, &VertexBufferId[5]);
        glDeleteBuffers(1, &IndexBufferId[5]);
        glDeleteVertexArrays(1, &VertexArrayId[5]);
        VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(MeshPoints, NULL, 4);
        
        // CONTROL MESH
        int rowNum = 10;
        int index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            for (int j = -rowNum; j < rowNum; j++)
            {
                MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
                index++;
            }
        }
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
            MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
        }
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
            MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
        }
        
        VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(MeshLines, NULL, 3);
        
        // CONTROL MESH TEXTURE TRAINGLE
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            for (int j = -rowNum; j < rowNum; j++)
            {
                MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
                MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                index++;
            }
        }
        VertexBufferSize[5] = sizeof(MeshTrianglePoints);
        createVAOs(MeshTrianglePoints, NULL, 5);
    }
    
    if (brown)
    {
        if (brownTime > 1.0)
            brown = false;
        MeshPoints[216].Position[1] += 0.002f;
        MeshLinePoints[216].Position[1] += 0.002f;
        MeshTexturePoints[216].Position[1] += 0.002f;
        MeshPoints[237].Position[1] += 0.002f;
        MeshLinePoints[237].Position[1] += 0.002f;
        MeshTexturePoints[237].Position[1] += 0.002f;
        MeshPoints[217].Position[1] += 0.002f;
        MeshLinePoints[217].Position[1] += 0.002f;
        MeshTexturePoints[217].Position[1] += 0.002f;
        MeshPoints[239].Position[1] -= 0.002f;
        MeshLinePoints[239].Position[1] -= 0.002f;
        MeshTexturePoints[239].Position[1] -= 0.002f;
        MeshPoints[218].Position[1] -= 0.002f;
        MeshLinePoints[218].Position[1] -= 0.002f;
        MeshTexturePoints[218].Position[1] -= 0.002f;
        
        MeshPoints[242].Position[1] += 0.002f;
        MeshLinePoints[242].Position[1] += 0.002f;
        MeshTexturePoints[242].Position[1] += 0.002f;
        MeshPoints[263].Position[1] += 0.002f;
        MeshLinePoints[263].Position[1] += 0.002f;
        MeshTexturePoints[263].Position[1] += 0.002f;
        MeshPoints[240].Position[1] -= 0.002f;
        MeshLinePoints[240].Position[1] -= 0.002f;
        MeshTexturePoints[240].Position[1] -= 0.002f;
        MeshPoints[261].Position[1] -= 0.002f;
        MeshLinePoints[261].Position[1] -= 0.002f;
        MeshTexturePoints[261].Position[1] -= 0.002f;

        
        glDeleteBuffers(1, &VertexBufferId[3]);
        glDeleteBuffers(1, &IndexBufferId[3]);
        glDeleteVertexArrays(1, &VertexArrayId[3]);
        
        glDeleteBuffers(1, &VertexBufferId[4]);
        glDeleteBuffers(1, &IndexBufferId[4]);
        glDeleteVertexArrays(1, &VertexArrayId[4]);
        
        glDeleteBuffers(1, &VertexBufferId[5]);
        glDeleteBuffers(1, &IndexBufferId[5]);
        glDeleteVertexArrays(1, &VertexArrayId[5]);
        VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(MeshPoints, NULL, 4);
        
        // CONTROL MESH
        int rowNum = 10;
        int index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            for (int j = -rowNum; j < rowNum; j++)
            {
                MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
                index++;
            }
        }
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
            MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
        }
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
            MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
        }
        
        VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(MeshLines, NULL, 3);
        
        // CONTROL MESH TEXTURE TRAINGLE
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            for (int j = -rowNum; j < rowNum; j++)
            {
                MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
                MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                index++;
            }
        }
        VertexBufferSize[5] = sizeof(MeshTrianglePoints);
        createVAOs(MeshTrianglePoints, NULL, 5);
    }
    
    // Camera matrix
    float oldX = cameraPos.x;
    float oldZ = cameraPos.z;
    if (resetCamera)
    {
        int rowNum = 10;
        for (int i = 0; i <= 2 * rowNum + 1; i++)
        {
            for (int j = -rowNum; j <= rowNum; j++)
            {
                MeshPoints[i * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, float(i) / 2, 0.0, 1.0}, {0.0, 1.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {0.0, 0.0} };
            }
        }
        
        for (int i = 0; i <= 2 * rowNum + 1; i++)
        {
            for (int j = -rowNum; j <= rowNum; j++)
            {
                MeshLinePoints[i * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, float(i) / 2, 0.0, 1.0}, {1.0, 1.0, 1.0, 1.0}, {0.0, 0.0, 1.0}, {0.0, 0.0} };
            }
        }
        
        for (int i = 0; i <= 2 * rowNum + 1; i++)
        {
            for (int j = -rowNum; j <= rowNum; j++)
            {
                float temp_i = i;
                float temp_j = j + rowNum;
                MeshTexturePoints[i * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, float(i) / 2, 0.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {temp_j / (2 * rowNum), temp_i / (2 * rowNum)} };
            }
        }
        VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(MeshPoints, NULL, 4);
        
        // CONTROL MESH
        int index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            for (int j = -rowNum; j < rowNum; j++)
            {
                MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
                index++;
            }
        }
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
            MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
        }
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
            MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
        }
        
        VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
        createVAOs(MeshLines, NULL, 3);
        
        // CONTROL MESH TEXTURE TRAINGLE
        index = 0;
        for (int i = -rowNum; i < rowNum; i++)
        {
            for (int j = -rowNum; j < rowNum; j++)
            {
                MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
                MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
                MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
                index++;
            }
        }
        VertexBufferSize[5] = sizeof(MeshTrianglePoints);
        createVAOs(MeshTrianglePoints, NULL, 5);
        
        rotationLRMatrix = mat4(1.0);
        rotationUDMatrix = mat4(1.0);
        cameraPos = glm::vec3(10.0, 10.0, 10.0f);
        resetCamera = false;
    }
    cameraPos = mat3(rotationUDMatrix) * mat3(rotationLRMatrix) * cameraPos;
    if (oldX * cameraPos.x < 0 && oldZ * cameraPos.z <0)
    {
        cameraUp = glm::vec3(0, -cameraUp.y, 0);
    }
    
    gViewMatrix = glm::lookAt(cameraPos,	// eye
                              glm::vec3(0.0, 0.0, 0.0),	// center
                              cameraUp);
    
    glUseProgram(programID);
    {
        glm::vec3 lightPos_1 = glm::vec3(-10, 30, 0);
        glUniform3f(LightID_1, lightPos_1.x, lightPos_1.y, lightPos_1.z);
        glm::vec3 lightPos_2 = glm::vec3(0, 10, 10);
        glUniform3f(LightID_2, lightPos_2.x, lightPos_2.y, lightPos_2.z);
        
        glm::mat4x4 ModelMatrix = glm::mat4(1.0);
        glUniformMatrix4fv(ViewMatrixID, 1, GL_FALSE, &gViewMatrix[0][0]);
        glUniformMatrix4fv(ProjMatrixID, 1, GL_FALSE, &gProjectionMatrix[0][0]);
        glUniformMatrix4fv(ModelMatrixID, 1, GL_FALSE, &ModelMatrix[0][0]);
        
        glEnable(GL_PROGRAM_POINT_SIZE);
        
        glBindVertexArray(VertexArrayId[0]);	// draw CoordAxes
        glDrawArrays(GL_LINES, 0, 6);
        
        glBindVertexArray(VertexArrayId[1]);
        glDrawArrays(GL_LINES, 0, 84);
        
        if (showModel)
        {
            glBindVertexArray(VertexArrayId[2]);
            glDrawElements(GL_TRIANGLES, NumIndices[2], GL_UNSIGNED_SHORT, (void*)0);
            
            for (int i = 11; i <= 96; i++) {
                glBindVertexArray(VertexArrayId[i]);
                glDrawArrays(GL_LINES, 0, 24);
            }
            
        }
        
        if (showMesh)
        {
            glBindVertexArray(VertexArrayId[3]);
            glDrawArrays(GL_LINES, 0, 1680);
            
            glBindVertexArray(VertexArrayId[4]);
            glDrawArrays(GL_POINTS, 0, 441);
        }
        
        if (showTexture && !smoothSurface)
        {
            glUniform1i(TextureID, 0);
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, Texture);
            glBindVertexArray(VertexArrayId[5]);
            glDrawArrays(GL_TRIANGLES, 0, 2400);
        }
        
        if(smoothSurface)
        {
            renderSmooth();
            glUniform1i(TextureID, 0);
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, Texture);
            glBindVertexArray(VertexArrayId[7]);
            glDrawArrays(GL_TRIANGLES, 0, 22600);
        }
        
        if (showSubdiv) {
            glBindVertexArray(VertexArrayId[8]);
            glDrawArrays(GL_POINTS, 0, 3721);
        }
//        glUniform1i(TextureID, 0);
//        glActiveTexture(GL_TEXTURE0);
//        glBindTexture(GL_TEXTURE_2D, HairTexture);
//        glBindVertexArray(VertexArrayId[9]);
//        glDrawArrays(GL_TRIANGLES, 0, 2400);
    }
    glUseProgram(0);
    // Draw GUI
    TwDraw();
    
    // Swap buffers
    glfwSwapBuffers(window);
    glfwPollEvents();
}
void moveVertex(void)
{
    glm::mat4 ModelMatrix = glm::mat4(1.0);
    GLint viewport[4];
    glGetIntegerv(GL_VIEWPORT, viewport);
    glm::vec4 vp = glm::vec4(viewport[0], viewport[1], viewport[2], viewport[3]);
    double xpos = 0,ypos = 0;
    glfwGetCursorPos(window, &xpos, &ypos);
    glm::vec3 oriCoordinate = glm::vec3(xpos, window_height - ypos, zpos);
    glm::vec3 newCoordinate = glm::unProject(oriCoordinate, gViewMatrix * ModelMatrix, gProjectionMatrix, vp);
    
    if (!is_zDirection)
    {
        curCoor.x = newCoordinate.x;
        curCoor.y = newCoordinate.y;
        curCoor.z = oriCoor.z;
    }
    else
    {
        curCoor.x = oriCoor.x;
        curCoor.y = oriCoor.y;
        curCoor.z = oriCoor.z + (oriCoor.x - newCoordinate.x);
    }
    float coord[3] = {curCoor.x, curCoor.y, curCoor.z};
    MeshPoints[gPickedIndex].SetPosition(coord);
    //printf("%d %f %f %f\n", gPickedIndex, MeshPoints[gPickedIndex].Position[0], MeshPoints[gPickedIndex].Position[1], MeshPoints[gPickedIndex].Position[2]);
    MeshLinePoints[gPickedIndex].SetPosition(coord);
    MeshTexturePoints[gPickedIndex].SetPosition(coord);
    
    glDeleteBuffers(1, &VertexBufferId[3]);
    glDeleteBuffers(1, &IndexBufferId[3]);
    glDeleteVertexArrays(1, &VertexArrayId[3]);
    
    glDeleteBuffers(1, &VertexBufferId[4]);
    glDeleteBuffers(1, &IndexBufferId[4]);
    glDeleteVertexArrays(1, &VertexArrayId[4]);
    
    glDeleteBuffers(1, &VertexBufferId[5]);
    glDeleteBuffers(1, &IndexBufferId[5]);
    glDeleteVertexArrays(1, &VertexArrayId[5]);
    VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshPoints, NULL, 4);
    
    // CONTROL MESH
    int rowNum = 10;
    int index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            index++;
        }
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
    }
    
    VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshLines, NULL, 3);
    
    // CONTROL MESH TEXTURE TRAINGLE
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            index++;
        }
    }
    VertexBufferSize[5] = sizeof(MeshTrianglePoints);
    createVAOs(MeshTrianglePoints, NULL, 5);
    
}
void pickObject(void)
{
    // Clear the screen in white
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    glUseProgram(pickingProgramID);
    {
        glm::mat4 ModelMatrix = glm::mat4(1.0); // TranslationMatrix * RotationMatrix;
        glm::mat4 MVP = gProjectionMatrix * gViewMatrix * ModelMatrix;
        
        // Send our transformation to the currently bound shader, in the "MVP" uniform
        
        // ATTN: DRAW YOUR PICKING SCENE HERE. REMEMBER TO SEND IN A DIFFERENT PICKING COLOR FOR EACH OBJECT BEFOREHAND
        glUniformMatrix4fv(PickingMatrixID, 1, GL_FALSE, &MVP[0][0]);
        glUniform1fv(pickingColorArrayID, 441, pickingColor);
        
        glBindVertexArray(VertexArrayId[4]);
        glDrawArrays(GL_POINTS, 0, 441);
        
    }
    glUseProgram(0);
    // Wait until all the pending drawing commands are really done.
    // Ultra-mega-over slow !
    // There are usually a long time between glDrawElements() and
    // all the fragments completely rasterized.
    glFlush();
    glFinish();
    
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    
    // Read the pixel at the center of the screen.
    // You can also use glfwGetMousePos().
    // Ultra-mega-over slow too, even for 1 pixel,
    // because the framebuffer is on the GPU.
    double xpos = 0, ypos = 0;
    glfwGetCursorPos(window, &xpos, &ypos);
    unsigned char data[4];
    glReadPixels(xpos, window_height - ypos, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, data); // OpenGL renders with (0,0) on bottom, mouse reports with (0,0) on top
    glReadPixels(xpos, window_height - ypos, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &zpos);
    // Convert the color back to an integer ID
    gPickedIndex = int(data[0])+int(data[1]);
    printf("%d %d\n", data[0], data[1]);
    if (gPickedIndex >= 0 && gPickedIndex <= 440)
    {
        std::ostringstream oss;
        oss << "point " << gPickedIndex;
        gMessage = oss.str();
        isPick = true;
        oriCoor.x = MeshPoints[gPickedIndex].Position[0];
        oriCoor.y = MeshPoints[gPickedIndex].Position[1];
        oriCoor.z = MeshPoints[gPickedIndex].Position[2];
    }
    else
    {
        gMessage = "background";
    }
    // Uncomment these lines to see the picking shader in effect
    //glfwSwapBuffers(window);
    //continue; // skips the normal rendering
}

void saveControlPoint()
{
    fstream file;
    file.open("cm.p3", ios::out | ios::binary);
    for (int i = 0; i < 441; i++){
        file << MeshPoints[i].Position[0] << " " << MeshPoints[i].Position[1] << " " << MeshPoints[i].Position[2] << " ";
    }
    file.close();
}

void loadControlPoint()
{
    string str;
    int i = 0, j = 0;
    ifstream in("cm.p3");
    stringstream streamStr;
    while (in >> str)
    {
        j++;
        streamStr << str;
        if (j % 3 == 1)
        {
            streamStr >> MeshPoints[i].Position[0];
            MeshLinePoints[i].Position[0] = MeshPoints[i].Position[0];
            MeshTexturePoints[i].Position[0] = MeshPoints[i].Position[0];
            streamStr.clear();
        }
        else if (j % 3 == 2)
        {
            streamStr >> MeshPoints[i].Position[1];
            MeshLinePoints[i].Position[1] = MeshPoints[i].Position[1];
            MeshTexturePoints[i].Position[1] = MeshPoints[i].Position[1];
            streamStr.clear();
        }
        else
        {
            streamStr >> MeshPoints[i].Position[2];
            MeshLinePoints[i].Position[2] = MeshPoints[i].Position[2];
            MeshTexturePoints[i].Position[2] = MeshPoints[i].Position[2];
            streamStr.clear();
            i++;
        }
    }
    
    glDeleteBuffers(1, &VertexBufferId[3]);
    glDeleteBuffers(1, &IndexBufferId[3]);
    glDeleteVertexArrays(1, &VertexArrayId[3]);
    
    glDeleteBuffers(1, &VertexBufferId[4]);
    glDeleteBuffers(1, &IndexBufferId[4]);
    glDeleteVertexArrays(1, &VertexArrayId[4]);
    
    glDeleteBuffers(1, &VertexBufferId[5]);
    glDeleteBuffers(1, &IndexBufferId[5]);
    glDeleteVertexArrays(1, &VertexArrayId[5]);
    VertexBufferSize[4] = sizeof(MeshPoints);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshPoints, NULL, 4);
    
    // CONTROL MESH
    int rowNum = 10;
    int index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshLines[4 * index] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 1] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 2] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshLines[4 * index + 3] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            index++;
        }
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i)];
        MeshLines[1600 + index++] = MeshLinePoints[(2 * rowNum) * (2 * rowNum + 1) + (rowNum + i + 1)];
    }
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i) * (2 * rowNum + 1) + (2 * rowNum)];
        MeshLines[1640 + index++] = MeshLinePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (2 * rowNum)];
    }
    
    VertexBufferSize[3] = sizeof(MeshLines);	// ATTN: this needs to be done for each hand-made object with the ObjectID (subscript)
    createVAOs(MeshLines, NULL, 3);
    
    // CONTROL MESH TEXTURE TRAINGLE
    index = 0;
    for (int i = -rowNum; i < rowNum; i++)
    {
        for (int j = -rowNum; j < rowNum; j++)
        {
            MeshTrianglePoints[6 * index] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 1] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 2] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 3] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j + 1)];
            MeshTrianglePoints[6 * index + 4] = MeshTexturePoints[(rowNum + i + 1) * (2 * rowNum + 1) + (rowNum + j)];
            MeshTrianglePoints[6 * index + 5] = MeshTexturePoints[(rowNum + i) * (2 * rowNum + 1) + (rowNum + j)];
            index++;
        }
    }
    VertexBufferSize[5] = sizeof(MeshTrianglePoints);
    createVAOs(MeshTrianglePoints, NULL, 5);
}

int initWindow(void)
{
    // Initialise GLFW
    if (!glfwInit()) {
        fprintf(stderr, "Failed to initialize GLFW\n");
        return -1;
    }
    
    glfwWindowHint(GLFW_SAMPLES, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    
    // Open a window and create its OpenGL context
    window = glfwCreateWindow(window_width, window_height, "Yao,Heng(06794920)", NULL, NULL);
    if (window == NULL) {
        fprintf(stderr, "Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\n");
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    
    // Initialize GLEW
    glewExperimental = true; // Needed for core profile
    if (glewInit() != GLEW_OK) {
        fprintf(stderr, "Failed to initialize GLEW\n");
        return -1;
    }
    
    // Initialize the GUI
    TwInit(TW_OPENGL_CORE, NULL);
    TwWindowSize(window_width, window_height);
    TwBar * GUI = TwNewBar("Picking");
    TwSetParam(GUI, NULL, "refresh", TW_PARAM_CSTRING, 1, "0.1");
    TwAddVarRW(GUI, "Last picked object", TW_TYPE_STDSTRING, &gMessage, NULL);
    
    // Set up inputs
    glfwSetCursorPos(window, window_width / 2, window_height / 2);
    glfwSetKeyCallback(window, keyCallback);
    glfwSetMouseButtonCallback(window, mouseCallback);
    
    return 0;
}

void initOpenGL(void)
{
    // Enable depth test
    glEnable(GL_DEPTH_TEST);
    // Accept fragment if it closer to the camera than the former one
    glDepthFunc(GL_LESS);
    // Cull triangles which normal is not towards the camera
    glEnable(GL_CULL_FACE);
    
    // Projection matrix : 45∞ Field of View, 4:3 ratio, display range : 0.1 unit <-> 100 units
    gProjectionMatrix = glm::perspective(45.0f, 1.0f, 0.1f, 100.0f);
    // Or, for an ortho camera :
    //gProjectionMatrix = glm::ortho(-4.0f, 4.0f, -3.0f, 3.0f, 0.0f, 100.0f); // In world coordinates
    
    // Camera matrix
    gViewMatrix = glm::lookAt(glm::vec3(10.0, 10.0, 10.0f),	// eye
                              glm::vec3(0.0, 0.0, 0.0),	// center
                              glm::vec3(0.0, 1.0, 0.0));	// up
    
    // Camera postion
    cameraPos = glm::vec3(10.0, 10.0, 10.0f);
    cameraUp = glm::vec3(0.0, 1.0, 0.0);
    
    // Create and compile our GLSL program from the shaders
    programID = LoadShaders("StandardShading.vertexshader", "StandardShading.fragmentshader");
    pickingProgramID = LoadShaders("Picking.vertexshader", "Picking.fragmentshader");
    
    // Get a handle for our "MVP" uniform
    MatrixID = glGetUniformLocation(programID, "MVP");
    ModelMatrixID = glGetUniformLocation(programID, "M");
    ViewMatrixID = glGetUniformLocation(programID, "V");
    ProjMatrixID = glGetUniformLocation(programID, "P");
    
    PickingMatrixID = glGetUniformLocation(pickingProgramID, "MVP");
    // Get a handle for our "pickingColorID" uniform
    pickingColorID = glGetUniformLocation(pickingProgramID, "PickingColor");
    // Get a handle for our "LightPosition" uniform
    LightID_1 = glGetUniformLocation(programID, "LightPosition_worldspace1");
    LightID_2 = glGetUniformLocation(programID, "LightPosition_worldspace2");
    TextureID = glGetUniformLocation(programID, "myTexture");
    Texture = load_texture_TGA("models/yaoheng.tga", &TextureWidth, &TextureHeight, GL_REPEAT, GL_REPEAT);
    HairTexture = load_texture_TGA("models/hair.tga", &TextureWidth, &TextureHeight, GL_REPEAT, GL_REPEAT);
    pickingColorArrayID = glGetUniformLocation(pickingProgramID, "PickingColorArray");
    
    int rowNum = 10;
    for (int i = 0; i <= 2 * rowNum + 1; i++)
    {
        for (int j = -rowNum; j <= rowNum; j++)
        {
            MeshPoints[i * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, float(i) / 2, -4.0, 1.0}, {0.0, 1.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {0.0, 0.0} };
        }
    }
    
    for (int i = -rowNum; i <= rowNum; i++)
    {
        for (int j = -rowNum; j <= rowNum; j++)
        {
            float temp_i = i + rowNum;
            float temp_j = j + rowNum;
            MeshHairPoints[(i + rowNum) * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, 10.0, float(i) / 2, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {temp_j / (2 * rowNum), temp_i / (2 * rowNum)} };
        }
    }
    
    for (int i = 0; i <= 2 * rowNum + 1; i++)
    {
        for (int j = -rowNum; j <= rowNum; j++)
        {
            MeshLinePoints[i * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, float(i) / 2, -4.0, 1.0}, {1.0, 1.0, 1.0, 1.0}, {0.0, 0.0, 1.0}, {0.0, 0.0} };
        }
    }
    
    for (int i = 0; i <= 2 * rowNum + 1; i++)
    {
        for (int j = -rowNum; j <= rowNum; j++)
        {
            float temp_i = i;
            float temp_j = j + rowNum;
            MeshTexturePoints[i * (2 * rowNum + 1) + (rowNum + j)] = (Vertex){ { (float)j / 2, float(i) / 2, -4.0, 1.0}, {0.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {temp_j / (2 * rowNum), temp_i / (2 * rowNum)} };
        }
    }
    
    for (int i = -rowNum; i <= rowNum; i++)
    {
        for (int j = -rowNum; j <= rowNum; j++)
        {
            int index = (rowNum + i) * (2 * rowNum + 1) + (rowNum + j);
            pickingColor[index] = float(index) / 255.0f;
        }
    }
    for (int i = 0; i < 61; i++) {
        for (int j = 0; j < 61; j++) {
            float temp_i = i / 60;
            float temp_j = j / 60;
            SmoothMeshPoints[i * 61 + j] = (Vertex){ { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 0.0, 1.0 }, { 0.0, 0.0, 1.0 }, {temp_j, temp_i} };
        }
    }
    createObjects();
    smileTime = 0.0f;
}

void createVAOs(Vertex Vertices[], unsigned short Indices[], int ObjectId) {
    
    GLenum ErrorCheckValue = glGetError();
    const size_t VertexSize = sizeof(Vertices[0]);
    const size_t RgbOffset = sizeof(Vertices[0].Position);
    const size_t Normaloffset = sizeof(Vertices[0].Color) + RgbOffset;
    const size_t UVoffset = sizeof(Vertices[0].Normal) + Normaloffset;
    
    // Create Vertex Array Object
    glGenVertexArrays(1, &VertexArrayId[ObjectId]);	//
    glBindVertexArray(VertexArrayId[ObjectId]);		//
    
    // Create Buffer for vertex data
    glGenBuffers(1, &VertexBufferId[ObjectId]);
    glBindBuffer(GL_ARRAY_BUFFER, VertexBufferId[ObjectId]);
    glBufferData(GL_ARRAY_BUFFER, VertexBufferSize[ObjectId], Vertices, GL_STATIC_DRAW);
    
    // Create Buffer for indices
    if (Indices != NULL) {
        glGenBuffers(1, &IndexBufferId[ObjectId]);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IndexBufferId[ObjectId]);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, IndexBufferSize[ObjectId], Indices, GL_STATIC_DRAW);
    }
    
    // Assign vertex attributes
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, VertexSize, 0);
    glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, VertexSize, (GLvoid*)RgbOffset);
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, VertexSize, (GLvoid*)Normaloffset);
    glVertexAttribPointer(3, 2, GL_FLOAT, GL_FALSE, VertexSize, (GLvoid*)UVoffset);
    
    glEnableVertexAttribArray(0);	// position
    glEnableVertexAttribArray(1);	// color
    glEnableVertexAttribArray(2);	// normal
    glEnableVertexAttribArray(3);	// uv
    
    // Disable our Vertex Buffer Object
    glBindVertexArray(0);
    
    ErrorCheckValue = glGetError();
    if (ErrorCheckValue != GL_NO_ERROR)
    {
        fprintf(
                stderr,
                "ERROR: Could not create a VBO: %s \n",
                gluErrorString(ErrorCheckValue)
                );
    }
}

void cleanup(void)
{
    // Cleanup VBO and shader
    for (int i = 0; i < NumObjects; i++) {
        glDeleteBuffers(1, &VertexBufferId[i]);
        glDeleteBuffers(1, &IndexBufferId[i]);
        glDeleteVertexArrays(1, &VertexArrayId[i]);
    }
    glDeleteProgram(programID);
    glDeleteProgram(pickingProgramID);
    glDeleteTextures(1, &TextureID);
    // Close OpenGL window and terminate GLFW
    glfwTerminate();
}

static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    // ATTN: MODIFY AS APPROPRIATE
    if (action == GLFW_PRESS) {
        switch (key)
        {
            case GLFW_KEY_A:
                rayCasting();
                break;
            case GLFW_KEY_D:
                brown = true;
                break;
            case GLFW_KEY_Q:
                smoothSurface = !smoothSurface;
                break;
            case GLFW_KEY_E:
                showSubdiv = !showSubdiv;
            case GLFW_KEY_S:
                saveControlPoint();
                break;
            case GLFW_KEY_SPACE:
                smile = true;
                break;
            case GLFW_KEY_LEFT:
                moveLeft = true;
                break;
            case GLFW_KEY_RIGHT:
                moveRight = true;
                break;
            case GLFW_KEY_UP:
                moveForward = true;
                break;
            case GLFW_KEY_DOWN:
                moveBackward = true;
                break;
            case GLFW_KEY_R:
                resetCamera = true;
                break;
            case GLFW_KEY_F:
                showModel = !showModel;
                break;
            case GLFW_KEY_C:
                showMesh = !showMesh;
                break;
            case GLFW_KEY_LEFT_SHIFT:
                is_zDirection = true;
                break;
            case GLFW_KEY_RIGHT_SHIFT:
                is_zDirection = true;
                break;
            case GLFW_KEY_T:
                showTexture = !showTexture;
                break;
            case GLFW_KEY_L:
                loadControlPoint();
                break;
            default:
                break;
        }
    }
    if (action == GLFW_RELEASE) {
        switch (key)
        {
            case GLFW_KEY_LEFT:
                moveLeft = false;
                break;
            case GLFW_KEY_RIGHT:
                moveRight = false;
                break;
            case GLFW_KEY_UP:
                moveForward = false;
                break;
            case GLFW_KEY_DOWN:
                moveBackward = false;
                break;
            case GLFW_KEY_LEFT_SHIFT:
                is_zDirection = false;
                break;
            case GLFW_KEY_RIGHT_SHIFT:
                is_zDirection = false;
                break;

            default:
                break;
        }
    }
}

static void mouseCallback(GLFWwindow* window, int button, int action, int mods)
{
    if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) {
        pickObject();
    }
    if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_RELEASE) {
        isPick = false;
        gPickedIndex = -1;
    }
}

int main(void)
{
    // initialize window
    int errorCode = initWindow();
    if (errorCode != 0)
        return errorCode;
    
    // initialize OpenGL pipeline
    initOpenGL();
    
    // For speed computation
    double lastTime = glfwGetTime();
    int nbFrames = 0;
    do {
        if (smile) {
            smileTime += 0.01f;
        }
        
        if (brown) {
            brownTime += 0.01f;
        }

        if (isPick) {
            moveVertex();
        }
        // DRAWING POINTS
        renderScene();
        
        
    } // Check if the ESC key was pressed or the window was closed
    while (glfwGetKey(window, GLFW_KEY_ESCAPE) != GLFW_PRESS &&
           glfwWindowShouldClose(window) == 0);
    
    cleanup();
    
    return 0;
}
